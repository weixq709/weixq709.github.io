---
title: 基础语法
createTime: 2025/09/26 09:46:53
permalink: /article/basic-syntax/
outline: [2, 4]
---

## 包

- 每个 Go 程序都由包构成
- 程序从 main 包开始运行
- 按照约定，包名与导入路径的最后一个元素一致

## 导入

- 单行导入

```go
import "fmt"
```

- 分组导入

```go
import (
  "fmt"
  "math"
)
```

> [!TIP]
> 推荐使用分组导入

## 导出名

导出名必须以大写字母开头， 任何「未导出」的名字在该包外均无法访问。

## 函数

函数可接受零个或多个参数。

```go
func add(x int, y int) {
  return x + y
}
```

多个函数参数类型相同时，除最后一个参数外，参数类型可以省略。

```go
func add(x, y int) {
  return x + y
}
```

函数支持返回任意个数的返回值

```go
func swap(x, y string) (string, string) {
  return y, x
}
```

函数错误处理

<p>通常，使用最后一个参数表示函数是否有错误产生。</p>

```go
import (
  "fmt",
  "errors",
  "log"
)

func getFullName(fristName, lastName string) (string, error) {
  if firstName == ""
    return "", errors.New("First name must be not empty")
  if lastName == ""
    return "", errors.New("Last name must be not empty")
  return firstName + lastName
}

func main() {
  fullName, err := getFullName("Dog", "Lea")
  if err != nil {
    log.Fatal(err)
    return
  }
  fmt.Println("fullName: ", fullName)
}
```

命名函数返回值
函数的返回值可被命名，它们会被视作定义在函数顶部的变量。

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

> [!TIP]
>
> 1. 返回值的命名应当能反应其含义
> 2. 没有参数的 return 语句会直接返回已命名的返回值，也就是「裸」返回值。
> 3. 裸返回语句应只在短函数中使用，在长函数中使用会影响代码可读性。

## 变量

### 声明变量

- 变量声明可以包含初始值，每个变量对应一个。
- 如果提供了初始值，则类型可以省略；变量会从初始值中推断出类型。

```go
var i, j int = 1, 2
```

### 短变量声明

```go
k := 3
```

> [!WARNING]
>
> 短变量声明仅允许在函数内部使用，函数外部每个语句必须以关键字开始。

## 基本类型

<style>
  table th:not(:last-child),
  table td:not(:last-child) {
    text-align: center;
  }

  table th:first-child,
  table td:first-child {
    text-align: left;
  }
</style>

<table width="100%">
  <tbody>
    <tr>
      <th width="65px">名称</th>
      <th width="80px">字节数</th>
      <th>零值</th>
      <th>最大值</th>
      <th>最小值</th>
      <th width="350px">说明</th>
    </tr>
    <tr>
      <td>bool</td>
      <td>1</td>
      <td>false</td>
      <td>-</td>
      <td>-</td>
      <td>布尔类型，真用常量true表示，假用常量false表示</td>
    </tr>
    <tr>
      <td>byte</td>
      <td>1</td>
      <td>0</td>
      <td>-128</td>
      <td>127</td>
      <td>字节类型，可看作uint8的别名类型</td>
    </tr>
    <tr>
      <td>string</td>
      <td>-</td>
      <td>""</td>
      <td>-</td>
      <td>-</td>
      <td>字符串类型（实质是字节序列）</td>
    </tr>
    <tr>
      <td>float32</td>
      <td>4</td>
      <td>0.0</td>
      <td>-2147483648</td>
      <td>2147483647</td>
      <td>由32位二进制数表示的浮点数类型</td>
    </tr>
    <tr>
      <td>float64</td>
      <td>8</td>
      <td>0</td>
      <td>-</td>
      <td>-</td>
      <td>由64位二进制数表示的浮点数类型</td>
    </tr>
    <tr>
      <td>rune</td>
      <td>4</td>
      <td>0</td>
      <td>-</td>
      <td>-</td>
      <td>rune类型，专门存储Unicode编码，可看作uint32的别名类型</td>
    </tr>
    <tr>
      <td>int</td>
      <td>4/8</td>
      <td>0</td>
      <td>32: -2<sup>32</sup><br/>64: -2<sup>64</sup></td>
      <td>32: 2<sup>32</sup>-1<br/>64: 2<sup>64</sup>-1</td>
      <td>有符号整数类型<br/>32位系统占4字节，64位系统占8字节</td>
    </tr>
    <tr>
      <td>int8</td>
      <td>1</td>
      <td>0</td>
      <td>-128</td>
      <td>127</td>
      <td>由8位二进制数表示的有符号整数类型</td>
    </tr>
    <tr>
      <td>int16</td>
      <td>2</td>
      <td>0</td>
      <td>-32768</td>
      <td>32767</td>
      <td>由16位二进制数表示的有符号整数类型</td>
    </tr>
    <tr>
      <td>int32</td>
      <td>4</td>
      <td>0</td>
      <td>-2<sup>32</sup></td>
      <td>2<sup>32</sup></td>
      <td>由32位二进制数表示的有符号整数类型</td>
    </tr>
    <tr>
      <td>int64</td>
      <td>8</td>
      <td>0</td>
      <td>-2<sup>64</sup></td>
      <td>2<sup>64</sup>-1</td>
      <td>由64位二进制数表示的有符号整数类型</td>
    </tr>
    <tr>
      <td>uint</td>
      <td>4/8</td>
      <td>0</td>
      <td>0</td>
      <td>32: 2<sup>32</sup>-1<br/>64: 2<sup>64</sup>-1</td>
      <td>无符号整数类型<br/>32位系统占4字节，64位系统占8字节</td>
    </tr>
    <tr>
      <td>uint8</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>127</td>
      <td>由8位二进制数表示的无符号整数类型</td>
    </tr>
    <tr>
      <td>uint16</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>65535</td>
      <td>由16位二进制数表示的无符号整数类型</td>
    </tr>
    <tr>
      <td>uint32</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>4294967295</td>
      <td>由32位二进制数表示的无符号整数类型</td>
    </tr>
    <tr>
      <td>uint64</td>
      <td>8</td>
      <td>0</td>
      <td>0</td>
      <td>2<sup>64</sup> - 1</td>
      <td>由64位二进制数表示的无符号整数类型</td>
    </tr>
    <tr>
      <td>uintptr</td>
      <td></td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>无符号整数类型，一个存储指针位模式的整数值。</td>
    </tr>
    <tr>
      <td>complex64</td>
      <td>8</td>
      <td>0</td>
      <td>-</td>
      <td>-</td>
      <td>由64位二进制数表示的复数类型，float32类型的实部和float32类型的虚部联合表示</td>
    </tr>
    <tr>
      <td>complex128</td>
      <td>16</td>
      <td>0</td>
      <td>-</td>
      <td>-</td>
      <td>由128位二进制数表示的复数类型，float64类型的实部和float64类型的虚部联合表示</td>
    </tr>
  </tbody>
</table>

### 类型转换

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

或者使用简洁形式

```go
i := 42
f := float64(i)
u := unit(f)
```

### 类型推断

使用已知类型变量为短变量赋值时，短变量类型与赋值的变量类型相同

```go
var i int = 3
// j 也是int类型
j := i
```

短变量声明时，右侧为数字时，取决于数字的精度

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

## 常量

- 常量的声明与变量类似，只不过使用 const 关键字。
- 常量可以是字符、字符串、布尔值或数值。
- 常量不能用 := 语法声明。

```go
const PI = 3.14
```

## 循环

Go 只有一种循环结构：for 循环。基本的 for 循环由三部分组成，它们用分号隔开：

- 初始化语句：在第一次迭代前执行
- 条件表达式：在每次迭代前求值
- 后置语句：在每次迭代的结尾执行

初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。一旦条件表达式求值为 false，循环迭代就会终止。

> [!TIP]
> for循环无小括号，大括号是必须的。

```go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

也可使用`range`进行遍历

```go
arr := []{1, 2, 3}
for i := range arr {
  fmt.Println(i)
}
```

初始化语句和后置语句是可选的

```go
func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
```

for 是 Go 中的「while」

```go
func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```

如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。

```go
func main() {
	for {
	}
}
```

## 分支语句

### if判断

1. 与 for 循环类似，表达式外无需小括号 ( )，而大括号 { } 则是必须的。
2. if 语句可以在条件表达式前执行一个简短语句。

```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}
```

3. 在 if 的简短语句中声明的变量同样可以在对应的任何 else 块中使用。

### switch

仅运行选定之后的case语句，而非所有之后的所有case。

```go
func category(name string) string {
	switch name {
    case "dog":
    case "pig":
    case "cat": return "animal"
    case "apple":
    case "orange":
    case "banana": return "fruit"
    default: panic("Unkown category")
	}
}

func main() {
  // 期望返回animal，实际报错
  fmt.Println(category("cat"))
}
```

对于以上情况，可以使用`fallthrough`关键字。

````go
func category(name string) string {
	switch name {
    case "dog": fallthrough
    case "pig": fallthrough
    case "cat": return "animal"
    case "apple": fallthrough
    case "orange": fallthrough
    case "banana": return "fruit"
    default: panic("Unkown category")
	}
}

也可以使用逗号分隔表达式
```go
func category(name string) string {
	switch name {
    case "dog", "pig", "cat": return "animal"
    case "apple", "orange", "banana": return "fruit"
    default: panic("Unkown category")
	}
}
````

func main() {
// cat
fmt.Println(category("cat"))
}

````
如果不使用`fallthrough`，相当于为每个case语句自动添加`break`。
另外，case后的值无需为常量，且取值不限于整数。

#### 无条件switch
无条件的 switch 同 switch true 一样。

```go
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("早上好！")
	case t.Hour() < 17:
		fmt.Println("下午好！")
	default:
		fmt.Println("晚上好！")
	}
}
````

## 数组

## 函数

## 范型

## 指针

## 结构体

结构体就是一组字段

```go
type Vetex struct {
  X int
  Y int
}
```

上面的结构体可以通过点号`.`访问

```go
v := Vertext{1, 2}
fmt.Println(v.X)
```

定义结构体

```go
// 方式一
v := Vertext{1, 2}

// 方式2: 命名字段
v := Vertext{X: 1, Y: 2}

// 方式3: 指定部分字段，未指定字段使用字段类型零值
// Y的类型是int，int类型零值为0
v := Vertext{X: 1}

// 方式4: 结构体指针
v := &Vertext{1, 2}
```

创建对象更常见的做法是使用构造函数

```go
func newVertex(x, y int) *Vertext {
  v := Vertext{}
  v.X = 1
  v.Y = 2
  // 返回结构体指针
  return &v
}
```

### 结构体指针

### 嵌套结构体

### 匿名结构体

匿名结构体必须使用变量进行接收

```go
// 全局
// 属性值均为空
var person = struct {
  name string
  age int
}{}

// 在函数中定义
func test() {
  // 指定字段名初始化
  p1 := struct {
    name string
    age int
  }{
    name: "张三",
    age: 18
  }

  // 按顺序初始化所有字段
  p2 := struct {
    name string
    age int
  }{
    "张三",
    18
  }

  // 按顺序初始化部分字段，编译报错
  p3 := struct {
    name string
    age int
  } {
    "张三"
  }
}
```

> [!TIP] 
> 匿名结构体按顺序初始化时，必须初始化所有字段。

## defer 推迟

defer 语句会将函数推迟到外层函数返回之后执行。
推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。

推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。
